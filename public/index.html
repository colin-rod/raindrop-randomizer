<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Random Raindrop Reader</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      margin: 0;
      padding: 16px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      min-height: 100vh;
      color: #212529;
    }
    
    .container {
      max-width: min(1100px, 100%);
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15), 0 8px 16px rgba(0,0,0,0.1);
      display: grid;
      grid-template-rows: auto 1fr;
    }
    
    .header {
      background: linear-gradient(135deg, #495057 0%, #343a40 100%);
      color: white;
      padding: 24px;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      border-radius: 16px 16px 0 0;
    }
    
    .header h1 {
      margin: 0;
      font-size: 28px;
      font-weight: 600;
    }
    
    .controls {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 16px;
      box-shadow: inset 0 -2px 4px rgba(0,0,0,0.05);
    }

    .filters-panel {
      border: none;
      margin: 0;
    }

    .filters-summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      list-style: none;
      cursor: pointer;
      padding: 16px 24px;
      font-weight: 600;
      color: #212529;
      background: rgba(255, 255, 255, 0.85);
    }

    .filters-summary::-webkit-details-marker {
      display: none;
    }

    .summary-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .summary-title {
      font-size: 18px;
    }

    .summary-hint {
      font-size: 14px;
      font-weight: 400;
      color: #6c757d;
    }

    .summary-icon {
      width: 24px;
      height: 24px;
      border-radius: 9999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #343a40;
      color: white;
      font-size: 16px;
      transition: transform 0.2s ease;
    }

    .filters-panel[open] .summary-icon {
      transform: rotate(180deg);
    }

    .filters-content {
      padding: 0 24px 24px;
      border-top: 1px solid rgba(0, 0, 0, 0.05);
      background: rgba(255, 255, 255, 0.9);
    }
    
    .form-group {
      margin-bottom: 16px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #374151;
    }

    select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #ced4da;
      border-radius: 8px;
      font-size: 16px;
      background: white;
      transition: all 0.3s ease;
      min-height: 44px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    @media (min-width: 768px) {
      .controls {
        padding: 16px 24px 24px;
        display: grid;
        gap: 16px;
      }

      .filters-summary {
        display: none;
      }

      .filters-content {
        padding: 0;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
        align-items: end;
        border-top: none;
        background: transparent;
      }

      .filters-content .form-group {
        margin-bottom: 0;
      }

      .actions,
      .filters-content .keyboard-hint {
        grid-column: 1 / -1;
      }

      .filters-content select {
        padding: 10px 14px;
        min-height: 42px;
      }

      .actions {
        padding: 0;
        background: transparent;
      }
    }

    .custom-date-range {
      display: none;
      margin-top: 12px;
      gap: 12px;
    }

    .custom-date-range.active {
      display: flex;
      flex-wrap: wrap;
    }

    .custom-date-range label {
      font-weight: 500;
      margin-bottom: 4px;
    }

    .custom-date-range .date-input {
      flex: 1 1 180px;
      display: flex;
      flex-direction: column;
    }

    .custom-date-range input[type="date"] {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #ced4da;
      border-radius: 8px;
      font-size: 16px;
      background: white;
      transition: border 0.3s ease;
      min-height: 44px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }

    .custom-date-range input[type="date"]:focus {
      outline: none;
      border-color: #495057;
      box-shadow: 0 0 0 3px rgba(73, 80, 87, 0.15), 0 4px 8px rgba(0,0,0,0.15);
    }

    select:focus {
      outline: none;
      border-color: #495057;
      box-shadow: 0 0 0 3px rgba(73, 80, 87, 0.15), 0 4px 8px rgba(0,0,0,0.15);
    }

    .actions {
      display: flex;
      gap: 12px;
      padding: 16px 24px 24px;
      background: rgba(255, 255, 255, 0.9);
      flex-wrap: wrap;
    }
    
    button {
      flex: 1;
      min-width: 120px;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      min-height: 44px;
      position: relative;
      overflow: hidden;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #495057 0%, #343a40 100%);
      color: white;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.25), 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
      color: white;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .btn-danger:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.25), 0 4px 12px rgba(0,0,0,0.15);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }
    
    .loading {
      pointer-events: none;
    }
    
    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 16px;
      height: 16px;
      margin: -8px 0 0 -8px;
      border: 2px solid transparent;
      border-top: 2px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #bookmark {
      flex: 1 1 auto;
      padding: 24px;
      min-height: 300px;
      background: white;
    }
    
    #bookmark.loading {
      display: flex;
      align-items: center;
      justify-content: center;
      color: #6b7280;
    }
    
    .bookmark-card {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 12px;
      padding: 24px;
      animation: fadeIn 0.5s ease;
      box-shadow: 0 8px 16px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.05);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .bookmark-title {
      margin: 0 0 16px 0;
      font-size: 24px;
      font-weight: 600;
      line-height: 1.3;
      color: #212529;
      text-align: left;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .bookmark-title a {
      color: inherit;
      text-decoration: none;
      display: inline-block;
      transition: color 0.3s ease, text-shadow 0.3s ease;
    }

    .bookmark-title a:hover,
    .bookmark-title a:focus {
      text-decoration: underline;
      text-decoration-color: #495057;
      text-underline-offset: 4px;
    }

    .bookmark-title a:focus-visible {
      outline: 3px solid rgba(73, 80, 87, 0.4);
      border-radius: 6px;
    }
    
    .bookmark-content {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 20px;
    }
    
    .bookmark-excerpt {
      font-size: 16px;
      line-height: 1.6;
      color: #6c757d;
      margin-bottom: 16px;
    }
    
    .bookmark-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 20px;
    }

    .tag {
      background: #e9ecef;
      color: #495057;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .bookmark-meta-info {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .length-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 0;
    }

    .length-short {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .length-medium {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #faeeba;
    }

    .length-long {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .meta-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      background: #e7f1ff;
      color: #1c3d5a;
      border: 1px solid #d0dcf0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin: 0;
    }

    .meta-badge__detail {
      font-weight: 500;
      font-size: 12px;
      opacity: 0.85;
    }
    
    .bookmark-link {
      display: inline-flex;
      align-items: center;
      padding: 12px 24px;
      background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
      color: white;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 500;
      transition: all 0.3s ease;
      gap: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .bookmark-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.25), 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .error-message {
      background: #f8f9fa;
      border: 1px solid #ced4da;
      color: #495057;
      padding: 16px;
      border-radius: 8px;
      margin: 16px 0;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .success-message {
      background: #f8f9fa;
      border: 1px solid #ced4da;
      color: #212529;
      padding: 16px;
      border-radius: 8px;
      margin: 16px 0;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }
    
    .modal-content {
      background: white;
      padding: 24px;
      border-radius: 12px;
      max-width: 400px;
      width: 100%;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3), 0 8px 16px rgba(0,0,0,0.15);
    }
    
    .modal-buttons {
      display: flex;
      gap: 12px;
      margin-top: 20px;
      justify-content: center;
    }
    
    .btn-secondary {
      background: #f8f9fa;
      color: #495057;
      border: 1px solid #ced4da;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .btn-secondary:hover {
      background: #e9ecef;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .keyboard-hint {
      text-align: center;
      color: #6c757d;
      font-size: 14px;
      margin-top: 16px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 8px;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    
    /* Mobile Optimizations */
    @media (max-width: 768px) {
      body {
        padding: 8px;
      }

      .container {
        border-radius: 12px;
      }

      .header {
        padding: 20px 16px;
      }

      .header h1 {
        font-size: 24px;
      }

      .controls {
        border-radius: 12px 12px 0 0;
      }

      .filters-summary {
        padding: 12px 16px;
      }

      .filters-summary .summary-title {
        font-size: 16px;
      }

      .filters-summary .summary-hint {
        font-size: 13px;
      }

      .filters-content {
        padding: 0 16px 16px;
      }

      .actions {
        padding: 16px;
        border-top: 1px solid rgba(0, 0, 0, 0.05);
      }

      .actions button {
        flex: none;
        min-width: 100%;
      }

      .keyboard-hint {
        display: none;
      }

      #bookmark {
        padding: 16px;
      }
      
      .bookmark-title {
        font-size: 20px;
      }
      
      .bookmark-content {
        max-height: 150px;
      }
    }
    
    @media (max-width: 480px) {
      .modal {
        padding: 16px;
      }
      
      .modal-buttons {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Random Raindrop</h1>
      <p style="margin: 8px 0 0; font-size: 16px; font-weight: 400; opacity: 0.85;">Find a serendipitous read from your Raindrop collections.</p>
    </div>
    
    <div class="controls">
      <details id="filtersPanel" class="filters-panel" open>
        <summary class="filters-summary">
          <span class="summary-text">
            <span class="summary-title">Filters</span>
            <span class="summary-hint">Tap to adjust filters</span>
          </span>
          <span class="summary-icon" aria-hidden="true">‚åÑ</span>
        </summary>
        <div class="filters-content">
          <div class="form-group">
            <label for="collections">Choose a collection:</label>
            <select id="collections" aria-label="Select bookmark collection">
              <option value="0">All Collections</option>
            </select>
          </div>

          <div class="form-group">
            <label for="lengthFilter">Article length:</label>
            <select id="lengthFilter" aria-label="Filter by article length">
              <option value="all">All Lengths</option>
              <option value="short">üìè Short (1-2 min)</option>
              <option value="medium">üìè Medium (3-6 min)</option>
              <option value="long">üìè Long (7+ min)</option>
            </select>
          </div>

          <div class="form-group">
            <label for="contentFilter">Content type:</label>
            <select id="contentFilter" aria-label="Filter by content type">
              <option value="all">All content</option>
              <option value="video">Video only</option>
            </select>
          </div>

          <div class="form-group">
            <label for="dateFilter">Date added:</label>
            <select id="dateFilter" aria-label="Filter by bookmark creation date">
              <option value="any">Any time</option>
              <option value="last7">Last 7 days</option>
              <option value="last30">Last 30 days</option>
              <option value="custom">Custom range‚Ä¶</option>
            </select>

            <div id="customDateContainer" class="custom-date-range" aria-hidden="true">
              <div class="date-input">
                <label for="customStartDate">Start date</label>
                <input type="date" id="customStartDate" name="customStartDate" aria-label="Custom start date" />
              </div>
              <div class="date-input">
                <label for="customEndDate">End date (optional)</label>
                <input type="date" id="customEndDate" name="customEndDate" aria-label="Custom end date" />
              </div>
            </div>
          </div>

          <div class="keyboard-hint">
            üí° Press <strong>Space</strong> for random, <strong>Delete</strong> to remove<br>
            üéØ Use filters to find articles that match your available time or mood
          </div>
        </div>

      </details>
      <div class="actions" role="group" aria-label="Bookmark actions">
        <button id="get" class="btn-primary" aria-label="Get random bookmark">
          <span class="btn-text">Get Random</span>
        </button>
        <button id="edit" class="btn-secondary" disabled aria-label="Edit current bookmark">
          <span class="btn-text">Edit</span>
        </button>
        <button id="delete" class="btn-danger" disabled aria-label="Delete current bookmark">
          <span class="btn-text">Delete</span>
        </button>
      </div>
    </div>
  </div>
  
  <div id="confirmModal" class="modal" style="display: none;" role="dialog" aria-labelledby="modalTitle" aria-modal="true">
    <div class="modal-content">
      <h3 id="modalTitle">Confirm Delete</h3>
      <p>Are you sure you want to delete this bookmark? This action cannot be undone.</p>
      <div class="modal-buttons">
        <button id="confirmDelete" class="btn-danger">Delete</button>
        <button id="cancelDelete" class="btn-secondary">Cancel</button>
      </div>
    </div>
  </div>

  <div id="editModal" class="modal" style="display: none;" role="dialog" aria-labelledby="editModalTitle" aria-modal="true">
    <div class="modal-content" style="text-align: left;">
      <h3 id="editModalTitle" style="text-align: center;">Edit Bookmark</h3>
      <form id="editForm">
        <div class="form-group">
          <label for="editTitle">Title</label>
          <input id="editTitle" name="title" type="text" required style="width: 100%; padding: 12px 16px; border: 2px solid #ced4da; border-radius: 8px; font-size: 16px;" />
        </div>
        <div class="form-group">
          <label for="editTags">Tags (comma separated)</label>
          <input id="editTags" name="tags" type="text" style="width: 100%; padding: 12px 16px; border: 2px solid #ced4da; border-radius: 8px; font-size: 16px;" />
        </div>
        <div class="form-group">
          <label for="editCollection">Collection</label>
          <select id="editCollection" name="collection" style="width: 100%; padding: 12px 16px; border: 2px solid #ced4da; border-radius: 8px; font-size: 16px; background: white;">
            <option value="" disabled selected>Loading collections...</option>
          </select>
        </div>
        <div id="editError" style="display: none; margin-bottom: 12px; color: #b22222; background: #f8d7da; border: 1px solid #f5c6cb; padding: 12px; border-radius: 8px;"></div>
        <div class="modal-buttons">
          <button type="submit" id="editSave" class="btn-primary" style="flex: 1;">
            <span class="btn-text">Save</span>
          </button>
          <button type="button" id="editCancel" class="btn-secondary" style="flex: 1;">Cancel</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    let current = null;
    let selectedCollection = null;
    let selectedLengthFilter = 'all';
    let selectedContentFilter = 'all';
    let collectionsCache = null;
    let selectedDateFilter = 'any';
    let customStartDate = '';
    let customEndDate = '';
    let editFormLoading = false;
    const defaultContentFilterLabels = {};
    const defaultDateFilterLabels = {};
    const filterStatsCache = new Map();
    let lastFilterStatsRequestId = 0;
    const numberFormatter = typeof Intl !== 'undefined' && typeof Intl.NumberFormat === 'function'
      ? new Intl.NumberFormat()
      : null;

    function setupResponsiveFilters() {
      const filtersPanel = document.getElementById("filtersPanel");
      if (!filtersPanel || typeof window === "undefined" || typeof window.matchMedia !== "function") {
        return;
      }

      const mobileQuery = window.matchMedia("(max-width: 768px)");
      const summary = filtersPanel.querySelector(".filters-summary");
      let userToggledOnMobile = false;

      if (summary) {
        summary.addEventListener("click", () => {
          if (mobileQuery.matches) {
            userToggledOnMobile = true;
          }
        });
      }

      const applyState = (matches) => {
        if (matches) {
          if (!userToggledOnMobile) {
            filtersPanel.open = false;
          }
        } else {
          filtersPanel.open = true;
          userToggledOnMobile = false;
        }
      };

      applyState(mobileQuery.matches);

      const handleChange = (event) => {
        const matches = typeof event.matches === "boolean" ? event.matches : mobileQuery.matches;
        applyState(matches);
      };

      if (typeof mobileQuery.addEventListener === "function") {
        mobileQuery.addEventListener("change", handleChange);
      } else if (typeof mobileQuery.addListener === "function") {
        mobileQuery.addListener(handleChange);
      }
    }

    function formatCount(value) {
      const numeric = Number(value);
      const safeValue = Number.isFinite(numeric) ? numeric : 0;
      return numberFormatter ? numberFormatter.format(safeValue) : String(safeValue);
    }

    function captureDefaultFilterLabels() {
      const contentSelect = document.getElementById("contentFilter");
      if (contentSelect) {
        Array.from(contentSelect.options).forEach(option => {
          defaultContentFilterLabels[option.value] = option.textContent;
          option.dataset.defaultLabel = option.textContent;
        });
      }

      const dateSelect = document.getElementById("dateFilter");
      if (dateSelect) {
        Array.from(dateSelect.options).forEach(option => {
          defaultDateFilterLabels[option.value] = option.textContent;
          option.dataset.defaultLabel = option.textContent;
        });
      }
    }

    captureDefaultFilterLabels();

    function setFilterSelectLoading(isLoading) {
      const selects = [
        document.getElementById("contentFilter"),
        document.getElementById("dateFilter")
      ];

      selects.forEach(select => {
        if (!select) return;

        if (isLoading) {
          if (!select.dataset.wasDisabled) {
            select.dataset.wasDisabled = select.disabled ? 'true' : 'false';
          }
          select.classList.add('loading');
          select.disabled = true;
          select.setAttribute('aria-busy', 'true');
        } else {
          const wasDisabled = select.dataset.wasDisabled === 'true';
          if (!wasDisabled) {
            select.disabled = false;
          }
          select.classList.remove('loading');
          select.removeAttribute('aria-busy');
          delete select.dataset.wasDisabled;
        }
      });
    }

    function applyFilterCounts(stats) {
      const contentSelect = document.getElementById("contentFilter");
      const dateSelect = document.getElementById("dateFilter");
      const hasStats = stats && typeof stats === 'object';

      if (contentSelect) {
        const totalItems = hasStats ? formatCount(stats.totalItems) : null;
        const videoItems = hasStats ? formatCount(stats.videoItems) : null;

        Array.from(contentSelect.options).forEach(option => {
          const defaultLabel = option.dataset.defaultLabel || defaultContentFilterLabels[option.value];
          if (!defaultLabel) return;

          if (!hasStats) {
            option.textContent = defaultLabel;
            return;
          }

          if (option.value === 'all') {
            option.textContent = `${defaultLabel} (${totalItems})`;
          } else if (option.value === 'video') {
            option.textContent = `${defaultLabel} (${videoItems})`;
          } else {
            option.textContent = defaultLabel;
          }
        });
      }

      if (dateSelect) {
        const totalItems = hasStats ? formatCount(stats.totalItems) : null;
        const last7Days = hasStats ? formatCount(stats.last7Days) : null;
        const last30Days = hasStats ? formatCount(stats.last30Days) : null;

        Array.from(dateSelect.options).forEach(option => {
          const defaultLabel = option.dataset.defaultLabel || defaultDateFilterLabels[option.value];
          if (!defaultLabel) return;

          if (!hasStats) {
            option.textContent = defaultLabel;
            return;
          }

          if (option.value === 'any') {
            option.textContent = `${defaultLabel} (${totalItems})`;
          } else if (option.value === 'last7') {
            option.textContent = `${defaultLabel} (${last7Days})`;
          } else if (option.value === 'last30') {
            option.textContent = `${defaultLabel} (${last30Days})`;
          } else {
            option.textContent = defaultLabel;
          }
        });
      }
    }

    async function updateFilterCounts(collectionId) {
      const normalizedId = collectionId != null ? String(collectionId) : '0';

      if (filterStatsCache.has(normalizedId)) {
        lastFilterStatsRequestId += 1;
        const cached = filterStatsCache.get(normalizedId);
        applyFilterCounts(cached);
        setFilterSelectLoading(false);
        return cached;
      }

      const requestId = ++lastFilterStatsRequestId;
      setFilterSelectLoading(true);
      try {
        const response = await fetch(`/api/getFilterStats?collectionId=${encodeURIComponent(normalizedId)}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const payload = await response.json();
        filterStatsCache.set(normalizedId, payload);
        if (requestId === lastFilterStatsRequestId) {
          applyFilterCounts(payload);
        }
        return payload;
      } catch (error) {
        console.error('Failed to fetch filter stats:', error);
        if (requestId === lastFilterStatsRequestId) {
          applyFilterCounts(null);
        }
        return null;
      } finally {
        if (requestId === lastFilterStatsRequestId) {
          setFilterSelectLoading(false);
        }
      }
    }

    try {
      const storedContentFilter = localStorage.getItem('raindrop_content_filter');
      if (storedContentFilter === 'video' || storedContentFilter === 'all') {
        selectedContentFilter = storedContentFilter;
      }
    } catch (error) {
      console.warn('Failed to read saved content filter preference:', error);
    }

    // Utility functions
    function showLoading(elementId) {
      const element = document.getElementById(elementId);
      element.classList.add('loading');
      if (elementId === 'bookmark') {
        element.innerHTML = '<div>Loading...</div>';
      }
    }

    function hideLoading(elementId) {
      const element = document.getElementById(elementId);
      element.classList.remove('loading');
    }

    function showError(message, retry = false) {
      let displayMessage = message;
      const normalizedMessage = typeof message === 'string' ? message.trim().toLowerCase() : '';
      if (selectedContentFilter === 'video' && normalizedMessage === 'no bookmarks available') {
        displayMessage = `${message} (video filter enabled ‚Äî try switching back to \"All content\".)`;
      }
      const retryBtn = retry ? `<button onclick="getRandom()" style="margin-top: 12px; padding: 8px 16px; background: #495057; color: white; border: none; border-radius: 6px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">Try Again</button>` : '';
      document.getElementById("bookmark").innerHTML = `
        <div class="error-message">
          <strong>Error:</strong> ${displayMessage}
          ${retryBtn}
        </div>
      `;
    }

    function showSuccess(message) {
      document.getElementById("bookmark").innerHTML = `
        <div class="success-message">
          ${message}
        </div>
      `;
    }

    function resolveBookmarkTimestamp(data) {
      if (!data) {
        return null;
      }

      const candidates = [data.created, data.lastUpdate];
      for (const candidate of candidates) {
        if (!candidate) {
          continue;
        }

        const date = new Date(candidate);
        if (!Number.isNaN(date.getTime())) {
          return date;
        }
      }

      return null;
    }

    function describeBookmarkTimestamp(data) {
      const date = resolveBookmarkTimestamp(data);
      if (!date) {
        return null;
      }

      let durationInSeconds = (date.getTime() - Date.now()) / 1000;
      if (!Number.isFinite(durationInSeconds)) {
        return null;
      }

      const supportsRelativeTime = typeof Intl !== 'undefined' && typeof Intl.RelativeTimeFormat === 'function';
      const formatter = supportsRelativeTime
        ? new Intl.RelativeTimeFormat(undefined, { numeric: 'auto' })
        : null;

      const divisions = [
        { amount: 60, unit: 'second' },
        { amount: 60, unit: 'minute' },
        { amount: 24, unit: 'hour' },
        { amount: 7, unit: 'day' },
        { amount: 4.34524, unit: 'week' },
        { amount: 12, unit: 'month' },
        { amount: Number.POSITIVE_INFINITY, unit: 'year' }
      ];

      for (const division of divisions) {
        if (Math.abs(durationInSeconds) < division.amount) {
          const rounded = Math.round(durationInSeconds);
          const absRounded = Math.abs(rounded);

          let relative;
          if (supportsRelativeTime && formatter) {
            relative = formatter.format(rounded, division.unit);
          } else if (absRounded === 0) {
            relative = 'just now';
          } else {
            const unitLabel = absRounded === 1 ? division.unit : `${division.unit}s`;
            const direction = rounded <= 0 ? 'ago' : 'from now';
            relative = `${absRounded} ${unitLabel} ${direction}`;
          }

          return {
            relative,
            absolute: date.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' }),
            iso: date.toISOString()
          };
        }

        durationInSeconds /= division.amount;
      }

      return null;
    }

    // Cache collections
    function saveCollectionsCache(collections) {
      try {
        localStorage.setItem('raindrop_collections', JSON.stringify({
          data: collections,
          timestamp: Date.now()
        }));
      } catch (e) {
        console.warn('Failed to cache collections:', e);
      }
    }

    function refreshCollectionCounts() {
      if (!Array.isArray(collectionsCache)) {
        return;
      }

      const collectionsSelect = document.getElementById("collections");
      if (!collectionsSelect) {
        return;
      }

      const totalCount = collectionsCache.reduce((sum, collection) => {
        const value = Number(collection.count);
        return sum + (Number.isFinite(value) ? value : 0);
      }, 0);

      const allCollectionsOption = collectionsSelect.querySelector('option[value="0"]') || collectionsSelect.children[0];
      if (allCollectionsOption) {
        allCollectionsOption.textContent = `All Collections (${totalCount})`;
      }

      collectionsCache.forEach(collection => {
        const option = collectionsSelect.querySelector(`option[value="${String(collection.id)}"]`);
        if (option) {
          option.textContent = `${collection.title} (${collection.count})`;
        }
      });

      populateEditCollectionsSelect(collectionsCache);
      saveCollectionsCache(collectionsCache);
    }

    function applyBookmarkRemovalToCache(bookmark) {
      if (!bookmark || !Array.isArray(collectionsCache)) {
        return;
      }

      const resolvedCollectionId = bookmark.collectionId
        ?? bookmark.collection?.$id
        ?? bookmark.collection?._id;

      if (resolvedCollectionId == null) {
        return;
      }

      const target = collectionsCache.find(collection => String(collection.id) === String(resolvedCollectionId));
      if (!target) {
        return;
      }

      const currentCount = Number(target.count) || 0;
      target.count = Math.max(0, currentCount - 1);
    }

    function sanitizeCount(value) {
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : 0;
    }

    function decrementCount(value) {
      return Math.max(0, sanitizeCount(value) - 1);
    }

    function resolveBookmarkCollectionId(bookmark) {
      if (!bookmark) {
        return null;
      }
      const resolved = bookmark.collectionId
        ?? bookmark.collection?.$id
        ?? bookmark.collection?._id;
      return resolved != null ? String(resolved) : null;
    }

    function applyBookmarkRemovalToFilterStats(bookmark) {
      if (!bookmark || filterStatsCache.size === 0) {
        return;
      }

      const normalizedCollectionId = resolveBookmarkCollectionId(bookmark);
      const now = Date.now();
      const createdDate = bookmark.created ? new Date(bookmark.created) : null;
      const createdTimestamp = createdDate && !Number.isNaN(createdDate.getTime())
        ? createdDate.getTime()
        : NaN;
      const sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1000;
      const thirtyDaysAgo = now - 30 * 24 * 60 * 60 * 1000;

      const isVideo = typeof bookmark.type === 'string' && bookmark.type.toLowerCase() === 'video';
      const inLast7Days = Number.isFinite(createdTimestamp) && createdTimestamp >= sevenDaysAgo;
      const inLast30Days = Number.isFinite(createdTimestamp) && createdTimestamp >= thirtyDaysAgo;

      const keysToUpdate = [];
      if (filterStatsCache.has('0')) {
        keysToUpdate.push('0');
      }
      if (normalizedCollectionId && filterStatsCache.has(normalizedCollectionId)) {
        keysToUpdate.push(normalizedCollectionId);
      }

      keysToUpdate.forEach(key => {
        const stats = filterStatsCache.get(key);
        if (!stats) {
          return;
        }

        const updatedStats = {
          totalItems: decrementCount(stats.totalItems),
          videoItems: isVideo ? decrementCount(stats.videoItems) : sanitizeCount(stats.videoItems),
          last7Days: inLast7Days ? decrementCount(stats.last7Days) : sanitizeCount(stats.last7Days),
          last30Days: inLast30Days ? decrementCount(stats.last30Days) : sanitizeCount(stats.last30Days)
        };

        filterStatsCache.set(key, updatedStats);

        if (String(selectedCollection ?? '0') === key) {
          applyFilterCounts(updatedStats);
        }
      });
    }

    function getCollectionsCache() {
      try {
        const cached = localStorage.getItem('raindrop_collections');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          // Cache valid for 1 hour
          if (Date.now() - timestamp < 3600000) {
            return data;
          }
        }
      } catch (e) {
        console.warn('Failed to read collections cache:', e);
      }
      return null;
    }

    // Load collections with caching
      async function loadCollections() {

        // Try cache first
        const cached = getCollectionsCache();
        if (cached) {
          populateCollections(cached);
          collectionsCache = cached;
          populateEditCollectionsSelect(cached);
          return;
        }

        try {
          const res = await fetch("/api/getCollections");
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          const collections = await res.json();
          populateCollections(collections);
          saveCollectionsCache(collections);
          collectionsCache = collections;
          populateEditCollectionsSelect(collections);
        } catch (error) {
          console.error("Failed to load collections:", error);
          showError(`Failed to load collections: ${error.message}`);
        }
      }

      function populateCollections(collections) {
        const sel = document.getElementById("collections");

        // Calculate total count for "All Collections"
        const totalCount = collections.reduce((sum, c) => sum + (c.count || 0), 0);

        // Update "All Collections" option with total count
        const allCollectionsOption = sel.children[0];
        allCollectionsOption.textContent = `All Collections (${totalCount})`;

        // Clear existing options except "All Collections"
        while (sel.children.length > 1) {
          sel.removeChild(sel.lastChild);
        }

        collections.forEach(c => {
          const opt = document.createElement("option");
          opt.value = c.id;
          opt.textContent = `${c.title} (${c.count})`;
          sel.appendChild(opt);
        });
        selectedCollection = sel.value || "0";
        updateFilterCounts(selectedCollection);
        sel.addEventListener("change", e => {
          selectedCollection = e.target.value;
          updateFilterCounts(selectedCollection);
        });

        // Set up length filter listener
        const lengthSel = document.getElementById("lengthFilter");
        selectedLengthFilter = lengthSel.value || "all";
        lengthSel.addEventListener("change", e => selectedLengthFilter = e.target.value);

        const contentSel = document.getElementById("contentFilter");
        if (contentSel) {
          if (selectedContentFilter !== 'video') {
            selectedContentFilter = 'all';
          }
          contentSel.value = selectedContentFilter;
          contentSel.addEventListener("change", e => {
            const value = e.target.value === 'video' ? 'video' : 'all';
            selectedContentFilter = value;
            try {
              localStorage.setItem('raindrop_content_filter', value);
            } catch (error) {
              console.warn('Failed to store content filter preference:', error);
            }
          });
        }

        const dateSel = document.getElementById("dateFilter");
        const customDateContainer = document.getElementById("customDateContainer");
        const customStartInput = document.getElementById("customStartDate");
        const customEndInput = document.getElementById("customEndDate");

        function updateCustomDateVisibility() {
          if (!customDateContainer) return;
          const shouldShow = selectedDateFilter === 'custom';
          customDateContainer.classList.toggle('active', shouldShow);
          customDateContainer.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
        }

        selectedDateFilter = dateSel?.value || 'any';
        updateCustomDateVisibility();

        if (dateSel) {
          dateSel.addEventListener("change", e => {
            selectedDateFilter = e.target.value;
            updateCustomDateVisibility();
          });
        }

        if (customStartInput) {
          customStartDate = customStartInput.value;
          customStartInput.addEventListener("change", e => {
            customStartDate = e.target.value;
          });
        }

        if (customEndInput) {
          customEndDate = customEndInput.value;
          customEndInput.addEventListener("change", e => {
            customEndDate = e.target.value;
          });
        }
      }

      function populateEditCollectionsSelect(collections) {
        const editSelect = document.getElementById("editCollection");
        if (!editSelect) return;

        editSelect.innerHTML = "";

        if (!collections || !collections.length) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "No collections available";
          opt.disabled = true;
          opt.selected = true;
          editSelect.appendChild(opt);
          editSelect.disabled = true;
          return;
        }

        editSelect.disabled = false;

        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "Select a collection";
        placeholder.disabled = true;
        placeholder.selected = true;
        placeholder.hidden = true;
        editSelect.appendChild(placeholder);

        collections.forEach(c => {
          const opt = document.createElement("option");
          opt.value = String(c.id);
          opt.textContent = `${c.title} (${c.count})`;
          editSelect.appendChild(opt);
        });
      }

      async function getRandom() {
        if (!selectedCollection) return;

        const getBtn = document.getElementById("get");
        const deleteBtn = document.getElementById("delete");
        const editBtn = document.getElementById("edit");

        showLoading('get');
        showLoading('bookmark');
        deleteBtn.disabled = true;
        if (editBtn) {
          editBtn.disabled = true;
        }

        try {
          const params = new URLSearchParams({
            collectionId: selectedCollection,
            lengthFilter: selectedLengthFilter
          });

          if (selectedContentFilter && selectedContentFilter !== 'all') {
            params.set('typeFilter', selectedContentFilter);
          }

          if (selectedDateFilter && selectedDateFilter !== 'any') {
            if (selectedDateFilter === 'custom') {
              const hasStart = customStartDate && customStartDate.trim().length > 0;
              const hasEnd = customEndDate && customEndDate.trim().length > 0;

              if (hasStart || hasEnd) {
                params.set('dateFilter', 'custom');
                if (hasStart) {
                  params.set('startDate', customStartDate);
                }
                if (hasEnd) {
                  params.set('endDate', customEndDate);
                }
              }
            } else {
              params.set('dateFilter', selectedDateFilter);
            }
          }

          const url = `/api/getRandom?${params.toString()}`;
          const res = await fetch(url);
          let data = null;

          try {
            data = await res.json();
          } catch (parseError) {
            if (!res.ok) {
              throw new Error(`HTTP error! status: ${res.status}`);
            }
            throw parseError;
          }

          if (!res.ok) {
            const message = data && data.error ? data.error : `HTTP error! status: ${res.status}`;
            throw new Error(message);
          }

          if (data.error) {
            showError(data.error, true);
            return;
          }

          current = data;
          displayBookmark(data);
          deleteBtn.disabled = false;
          if (editBtn) {
            editBtn.disabled = false;
          }

        } catch (error) {
          console.error("Failed to get random bookmark:", error);
          const fallbackMessage = 'Failed to get random bookmark.';
          const message = (error && error.message) ? error.message : fallbackMessage;
          if (message.startsWith('HTTP error')) {
            showError(`${fallbackMessage} ${message}`, true);
          } else {
            showError(message, true);
          }
        } finally {
          hideLoading('get');
          hideLoading('bookmark');
          if (editBtn && current) {
            editBtn.disabled = false;
          }
        }
      }

    function displayBookmark(data) {
      const tags = data.tags && data.tags.length > 0 
        ? `<div class="bookmark-meta">${data.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}</div>`
        : '';
      
      // Create length badge if available
      const lengthBadge = data.lengthEstimate
        ? `<div class="length-badge length-${data.lengthEstimate.category.toLowerCase()}">
             üìè ${data.lengthEstimate.category} ‚Ä¢ ${data.lengthEstimate.readTime}
           </div>`
        : '';

      const timestampInfo = describeBookmarkTimestamp(data);
      const timestampBadge = timestampInfo
        ? `<time class="meta-badge" datetime="${timestampInfo.iso}" title="${timestampInfo.absolute}">
             üïí Added ${timestampInfo.relative}${timestampInfo.absolute ? `<span class="meta-badge__detail">‚Ä¢ ${timestampInfo.absolute}</span>` : ''}
           </time>`
        : '';

      const metaBadges = [lengthBadge, timestampBadge].filter(Boolean).join('');
      const metaSection = metaBadges ? `<div class="bookmark-meta-info">${metaBadges}</div>` : '';

        document.getElementById("bookmark").innerHTML = `
          <div class="bookmark-card">
            <h2 class="bookmark-title"><a href="${data.link}" target="_blank" rel="noopener noreferrer">${data.title || 'Untitled'}</a></h2>
            ${metaSection}
            <div class="bookmark-content">
              <div class="bookmark-excerpt">${data.excerpt || "No description available"}</div>
              ${data.note ? `<p><strong>Note:</strong> ${data.note}</p>` : ""}
            </div>
            ${tags}
            <a href="${data.link}" target="_blank" class="bookmark-link" rel="noopener noreferrer">
              üìñ Read Original
            </a>
          </div>
        `;

        const editBtn = document.getElementById("edit");
        if (editBtn) {
          editBtn.disabled = false;
        }
      }

    function showDeleteModal() {
      document.getElementById("confirmModal").style.display = "flex";
      document.getElementById("confirmDelete").focus();
    }

      function hideDeleteModal() {
        document.getElementById("confirmModal").style.display = "none";
      }

      function setEditError(message) {
        const errorEl = document.getElementById("editError");
        if (!errorEl) return;
        if (message) {
          errorEl.textContent = message;
          errorEl.style.display = "block";
        } else {
          errorEl.textContent = "";
          errorEl.style.display = "none";
        }
      }

      function showEditModal() {
        if (!current || editFormLoading) return;

        if (collectionsCache) {
          populateEditCollectionsSelect(collectionsCache);
        }

        const modal = document.getElementById("editModal");
        const titleInput = document.getElementById("editTitle");
        const tagsInput = document.getElementById("editTags");
        const collectionSelect = document.getElementById("editCollection");

        titleInput.value = current.title || "";
        tagsInput.value = Array.isArray(current.tags) ? current.tags.join(", ") : "";

        const currentCollectionId = current.collectionId ?? current.collection?.$id ?? current.collection?._id ?? "";
        if (collectionSelect) {
          const desiredValue = currentCollectionId != null ? String(currentCollectionId) : "";
          if (desiredValue && [...collectionSelect.options].some(opt => opt.value === desiredValue)) {
            collectionSelect.value = desiredValue;
          } else if (collectionSelect.options.length > 1) {
            collectionSelect.selectedIndex = 1;
          } else if (collectionSelect.options.length) {
            collectionSelect.selectedIndex = 0;
          }
        }

        setEditError("");
        modal.style.display = "flex";
        setTimeout(() => titleInput.focus(), 0);
      }

      function hideEditModal(force = false) {
        if (editFormLoading && !force) return;
        const modal = document.getElementById("editModal");
        modal.style.display = "none";
        setEditError("");
      }

      async function handleEditSubmit(event) {
        event.preventDefault();
        if (!current || editFormLoading) return;

        const titleInput = document.getElementById("editTitle");
        const tagsInput = document.getElementById("editTags");
        const collectionSelect = document.getElementById("editCollection");
        const saveBtn = document.getElementById("editSave");
        const cancelBtn = document.getElementById("editCancel");

        const title = titleInput.value.trim();
        if (!title) {
          setEditError("Title is required.");
          titleInput.focus();
          return;
        }

        const tags = tagsInput.value
          .split(",")
          .map(tag => tag.trim())
          .filter(tag => tag.length > 0);

        const selectedCollectionRaw = collectionSelect && collectionSelect.value
          ? collectionSelect.value
          : current.collectionId ?? current.collection?.$id ?? current.collection?._id ?? null;
        const collectionId = selectedCollectionRaw !== null && selectedCollectionRaw !== ""
          ? Number(selectedCollectionRaw)
          : null;

        const payload = {
          id: current._id,
          title,
          tags,
          collectionId
        };

        editFormLoading = true;
        setEditError("");
        showLoading('editSave');
        saveBtn.disabled = true;
        cancelBtn.disabled = true;

        try {
          const res = await fetch("/api/update", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(payload)
          });

          let data;
          try {
            data = await res.json();
          } catch (parseError) {
            data = null;
          }

          if (!res.ok || (data && data.error)) {
            const message = data && data.error ? data.error : `Failed to update bookmark (status ${res.status})`;
            throw new Error(message);
          }

          const updatedBookmark = data?.item || data || {};
          current = {
            ...current,
            ...updatedBookmark,
            title: updatedBookmark.title ?? title,
            tags: Array.isArray(updatedBookmark.tags) ? updatedBookmark.tags : tags,
            collectionId: updatedBookmark.collectionId ?? (collectionId ?? current.collectionId),
            collection: updatedBookmark.collection ?? current.collection
          };

          displayBookmark(current);
          hideEditModal(true);
        } catch (error) {
          console.error("Failed to update bookmark:", error);
          setEditError(error.message || "Failed to update bookmark.");
        } finally {
          editFormLoading = false;
          hideLoading('editSave');
          saveBtn.disabled = false;
          cancelBtn.disabled = false;
        }
      }

      async function confirmDeleteBookmark() {
        if (!current) return;

        hideDeleteModal();
        const deleteBtn = document.getElementById("delete");
        const editBtn = document.getElementById("edit");

        showLoading('delete');
        deleteBtn.disabled = true;
        if (editBtn) {
          editBtn.disabled = true;
        }

        try {
          const res = await fetch(`/api/delete?id=${current._id}`);
          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }
          const data = await res.json();
          if (data.success) {
            showSuccess("‚úÖ Bookmark deleted! Loading new random bookmark...");
            applyBookmarkRemovalToCache(current);
            refreshCollectionCounts();
            applyBookmarkRemovalToFilterStats(current);
            const activeCollectionId = selectedCollection != null ? selectedCollection : '0';
            updateFilterCounts(activeCollectionId);
            current = null;
            if (editBtn) {
              editBtn.disabled = true;
            }
            // Automatically get a new random bookmark
            setTimeout(() => getRandom(), 1500);
          }
        } catch (error) {
          console.error("Failed to delete bookmark:", error);
          showError(`Failed to delete bookmark: ${error.message}`);
          deleteBtn.disabled = false;
          if (editBtn && current) {
            editBtn.disabled = false;
          }
        } finally {
          hideLoading('delete');
        }
      }

      // Event listeners
      document.getElementById("get").addEventListener("click", getRandom);
      document.getElementById("delete").addEventListener("click", showDeleteModal);
      document.getElementById("confirmDelete").addEventListener("click", confirmDeleteBookmark);
      document.getElementById("cancelDelete").addEventListener("click", hideDeleteModal);
      document.getElementById("edit").addEventListener("click", showEditModal);
      document.getElementById("editForm").addEventListener("submit", handleEditSubmit);
      document.getElementById("editCancel").addEventListener("click", hideEditModal);

    // Keyboard shortcuts
    document.addEventListener("keydown", function(e) {
      // Prevent shortcuts when typing in inputs or modal is open
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
        return;
      }
      
      if (document.getElementById("confirmModal").style.display === "flex") {
        if (e.key === "Escape") {
          e.preventDefault();
          hideDeleteModal();
        } else if (e.key === "Enter") {
          e.preventDefault();
          confirmDeleteBookmark();
        }
        return;
      }

      if (document.getElementById("editModal").style.display === "flex") {
        if (e.key === "Escape") {
          e.preventDefault();
          hideEditModal();
        } else if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handleEditSubmit(new Event("submit", { cancelable: true }));
        }
        return;
      }

      if (e.code === "Space") {
        e.preventDefault();
        if (!document.getElementById("get").classList.contains('loading')) {
          getRandom();
        }
      } else if (e.key === "Delete" || e.key === "Backspace") {
        e.preventDefault();
        if (current && !document.getElementById("delete").disabled) {
          showDeleteModal();
        }
      }
    });

    // Modal click outside to close
    document.getElementById("confirmModal").addEventListener("click", function(e) {
      if (e.target === this) {
        hideDeleteModal();
      }
    });

    document.getElementById("editModal").addEventListener("click", function(e) {
      if (e.target === this) {
        hideEditModal();
      }
    });

    // Initialize app
    setupResponsiveFilters();
    loadCollections();
  </script>
</body>
</html>